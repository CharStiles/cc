<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.js"></script>
  </head>
  <body>
    <main></main>
    <script>
    
    // sketch.js
// Cat Eyes (hour marks) + Goldfish path Clock
  // Hour marks: 12 pairs of diamond-slit pupils (radial orientation)
  // Always-there irises behind each slit (visible around the pupil)
  // Active hour: yellow eye "pops" open with easing, alternates L/R each second (metronome)
  // Goldfish: smooth wriggly closed curve; rotates each minute; head moves smoothly; short fading tail
  // Minute-of-hour: outer arc

const BG = 12;
const PUPIL = 0;
const PUPIL_ALPHA = 230;

const EYE_YELLOW = [210, 180, 40];

function setup() {
  createCanvas(700, 700);
  angleMode(RADIANS);
  smooth();
}

function draw() {
  background(BG);

  // snap center to integers to reduce subpixel shimmer
  const cx = floor(width * 0.5);
  const cy = floor(height * 0.5);
  const R = min(width, height) * 0.42;

  // ---- Smooth wall-clock time ----
  const now = new Date();
  const h24 = now.getHours();
  const m = now.getMinutes();
  const s = now.getSeconds();
  const ms = now.getMilliseconds();

  const h12 = ((h24 % 12) + 12) % 12;

  // smooth 0..1 within the current minute
  const withinMinute = (s + ms / 1000) / 60;

  // smooth 0..1 over the hour
  const minuteProgress = (m + withinMinute) / 60;

  // outer minute arc
  drawMinuteArc(cx, cy, R * 1.06, minuteProgress);

  // hour ring: cat eyes + eased yellow flash
  drawHourEyesRing(cx, cy, R, h12, s, ms);

  // goldfish: wriggly parametric path, rotated per minute
  drawGoldfishWriggle(cx, cy, R * 0.20, withinMinute, now);
}

// =========================
// Outer minute arc
// =========================
function drawMinuteArc(cx, cy, r, progress01) {
  noFill();
  stroke(80, 120);
  strokeWeight(3);
  arc(cx, cy, r * 2, r * 2, -HALF_PI, -HALF_PI + TWO_PI);

  stroke(220, 160);
  strokeWeight(4);
  arc(cx, cy, r * 2, r * 2, -HALF_PI, -HALF_PI + TWO_PI * progress01);
}

// =========================
// Hour marks: pairs of diamond-slit pupils
// =========================
function drawHourEyesRing(cx, cy, ringR, currentHourIndex, sInt, ms) {
  for (let i = 0; i < 12; i++) {
    const a = -HALF_PI + (TWO_PI * i) / 12; // 12 o'clock at top
    const x = cx + cos(a) * ringR;
    const y = cy + sin(a) * ringR;

    // perpendicular direction to separate the two eyes
    const px = -sin(a);
    const py = cos(a);

    const eyeSeparation = ringR * 0.08;
    const leftX = x + px * (eyeSeparation * 0.5);
    const leftY = y + py * (eyeSeparation * 0.5);
    const rightX = x - px * (eyeSeparation * 0.5);
    const rightY = y - py * (eyeSeparation * 0.5);

    const slitLen = ringR * 0.080;
    const slitWid = ringR * 0.018;

    // radial orientation (pointy ends toward center/outward)
    const pupilAngle = a;

    // --- ALWAYS-THERE irises ---
    // Key fix: make iris bigger than the pupil so it shows around the diamond.
    // (Previously your iris was smaller than the diamond -> completely hidden.)
    const baseIrisR = slitLen * 0.62; // ~ "1/5 of eye vibe" but must be > pupil size to be visible
    noStroke();
    fill(210, 180, 40, 70); // bump alpha so it reads as "eyes in darkness"
    circle(leftX, leftY, baseIrisR * 2);
    circle(rightX, rightY, baseIrisR * 2);

    // Active hour: yellow eye pops open behind ONE pupil, alternating each second
    if (i === currentHourIndex) {
      const blinkLeft = (sInt % 2 === 0);

      // 0..1 within current second
      const t = constrain(ms / 1000, 0, 1);

      // pop quickly then hold
      const tt = min(1, t / 0.35);

      const pop = easeOutBack(tt);
      const bright = easeOutCubic(tt);

      // Pop eye slightly larger than base iris so it feels explosive
      const r = baseIrisR * (0.85 + 0.55 * pop);
      const alpha = 80 + 175 * bright; // 80..255

      noStroke();
      fill(EYE_YELLOW[0], EYE_YELLOW[1], EYE_YELLOW[2], alpha);

      if (blinkLeft) circle(leftX, leftY, r * 2);
      else circle(rightX, rightY, r * 2);
    }

    // pupils on top
    noStroke();
    fill(PUPIL, PUPIL_ALPHA);
    drawDiamondSlit(leftX, leftY, slitLen, slitWid, pupilAngle);
    drawDiamondSlit(rightX, rightY, slitLen, slitWid, pupilAngle);
  }
}

function drawDiamondSlit(x, y, len, wid, ang) {
  push();
  translate(x, y);
  rotate(ang);
  beginShape();
  vertex(-len * 0.5, 0);
  vertex(0, -wid * 0.5);
  vertex(len * 0.5, 0);
  vertex(0, wid * 0.5);
  endShape(CLOSE);
  pop();
}

// =========================
// Goldfish: wriggly "Brownian-ish" smooth closed curve (parametric)
// - same curve always (formula), but rotated to a new orientation each minute
// - head moves smoothly with withinMinute t
// - short fading tail behind head
// =========================
function drawGoldfishWriggle(cx, cy, regionR, t, now) {
  const r = regionR * 0.95;

  // minute index since epoch => stable "seed" per minute
  const minuteIndex = floor(now.getTime() / 60000);

  // deterministic rotation per minute (0..TWO_PI), no jitter inside the minute
  const rot = hash01(minuteIndex) * TWO_PI;

  // draw full path faint (so the "track" is visible)
  const samples = 260;
  noFill();
  stroke(180, 28);
  strokeWeight(1.4);
  beginShape();
  for (let i = 0; i < samples; i++) {
    const tt = i / (samples - 1);
    const p = wrigglePoint(tt, r, rot);
    vertex(cx + p.x, cy + p.y);
  }
  endShape();

  // head position
  const head = wrigglePoint(t, r, rot);

  // tail behind head: draw only a short segment with fade (low shimmer)
  const tailSegs = 22;
  const tailSpan = 0.22; // fraction of the loop behind head (bigger = longer trail)
  strokeWeight(2.8);
  for (let i = 0; i < tailSegs; i++) {
    const k0 = i / tailSegs;
    const k1 = (i + 1) / tailSegs;

    // go backwards along t (wrap around)
    const tt1 = wrap01(t - tailSpan * k0);
    const tt0 = wrap01(t - tailSpan * k1);

    const p1 = wrigglePoint(tt1, r, rot);
    const p0 = wrigglePoint(tt0, r, rot);

    const alpha = lerp(190, 15, k0); // bright near head -> faint further back
    stroke(210, alpha);
    line(cx + p0.x, cy + p0.y, cx + p1.x, cy + p1.y);
  }

  // fish dot
  noStroke();
  fill(210, 170, 60, 235);
  circle(cx + head.x, cy + head.y, regionR * 0.18);
}

// A smooth, wriggly closed curve: sum of harmonics (feels “Brownian-ish” but not noisy/jittery)
// More harmonics => longer-looking path within the same minute (feels less “slow”)
function wrigglePoint(t, r, rot) {
  const ph = TWO_PI * t;

  // "wriggle recipe": a few harmonics; tweak coefficients for taste
  // This is deterministic & smooth (no per-frame randomness).
  const x =
    r * (0.55 * cos(1 * ph) +
         0.22 * cos(5 * ph + 0.8) +
         0.16 * sin(9 * ph + 1.7) +
         0.10 * cos(13 * ph + 2.3));

  const y =
    r * (0.55 * sin(1 * ph) +
         0.25 * sin(4 * ph + 1.2) +
         0.14 * cos(8 * ph + 0.4) +
         0.10 * sin(12 * ph + 2.0));

  // rotate the whole curve per minute
  const xr = x * cos(rot) - y * sin(rot);
  const yr = x * sin(rot) + y * cos(rot);

  return { x: xr, y: yr };
}

function wrap01(t) {
  t = t % 1;
  if (t < 0) t += 1;
  return t;
}

// deterministic hash -> 0..1 (stable across frames)
function hash01(n) {
  // classic sine hash
  const x = sin(n * 12.9898 + 78.233) * 43758.5453123;
  return x - floor(x);
}

// =========================
// Easing helpers
// =========================
function easeOutCubic(t) {
  return 1 - pow(1 - t, 3);
}

function easeOutBack(t) {
  const c1 = 1.70158;
  const c3 = c1 + 1;
  return 1 + c3 * pow(t - 1, 3) + c1 * pow(t - 1, 2);
}

    </script>
  </body>
</html>
