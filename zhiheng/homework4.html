<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js"></script>

    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />

  </head>
  <body>
    <main>
    </main>
    <script>
    
    
let video;

let program, shadertime;

function setup() {
  noCursor();
  createCanvas(400, 400, WEBGL);
    program = createShader(vert, frag);
  shaderTime =0.;
 // fullscreen(true);
}


function draw() {
  noCursor();
  var right = []
  var left = []
  background(255,255)
    translate(-width/2.,-height/2.)
    shader(program);
  shaderTime+= 0.00001;
     program.setUniform('mx', mouseX);
   program.setUniform('my',mouseY);
  
   program.setUniform('u_resolution', [width*2., height*2.]);

    program.setUniform('u_time', shaderTime);
    program.setUniform('min', float((minute()/1.5) + 10 ));
    program.setUniform('hour', float(hour() ));
  program.setUniform("uTexture", cursor);

   // rect gives us some geometry on the screen
   rect(0,0,width, height);
  
  shaderTime++;

}

function mouseClicked(){
  isClicked = !isClicked;
  shaderTime =0;
}

var vert = `
#ifdef GL_ES
      precision highp float;
      precision highp int;
    #endif

    // attributes, in
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    attribute vec4 aVertexColor;

    // attributes, out
    varying vec3 var_vertPos;
    varying vec4 var_vertCol;
    varying vec3 var_vertNormal;
    varying vec2 var_vertTexCoord;

    // matrices
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    //uniform mat3 uNormalMatrix;

    void main() {
      gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);

      // just passing things through
      // var_vertPos      = aPosition;
      // var_vertCol      = aVertexColor;
      // var_vertNormal   = aNormal;
      // var_vertTexCoord = aTexCoord;
    }
`;
//YOUR CODE GOES HERE IN BETWEEN THE tick MARKS
var frag = `


#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;
uniform float u_vol;
// http://www.iquilezles.org/www/articles/palettes/palettes.htm 
// to see this function graphed out go to: https://www.desmos.com/calculator/rz7abjujdj
vec3 cosPalette( float t , vec3 brightness, vec3 contrast, vec3 osc, vec3 phase)
{

    return brightness + contrast*cos( 6.28318*(osc*t+phase) );
}

void main() {
    
    vec2 pos = ((gl_FragCoord.xy/u_resolution) - 0.5)*2.0; // origin is in center
    
    // who remembers SOH CAH TOA ?
    // tan, given an angle will return the ratio
    // so if we only have the ratio of position

  
    float angle = atan(pos.y,pos.x);
  
    	float r_bri = sin(angle + u_time);
  	  	float g_bri = cos(length(pos*10.)-u_time);
  		float b_bri = cos(angle+ cos(length(pos*15.)) + u_time);
  
    float osc_v = sin(angle + u_time); 
    // sin returns a number from -1 to 1, and colors are from 0 to 1, so thats 
    // why you only see red on the screen half the time. the angle goes around
    // the screen, adding time moves it clockwise
    
	float ringFrequency = 5.; // making this number bigger will increase frequency
	float Pha = cos(length(pos*ringFrequency) - u_time); 
	// the distance (aka length) from the center put in a cos, time moves the 
	// circles in. 
	
	float t = cos(angle+ cos(length(pos*ringFrequency *3.))); 
	// this combines what we learned in the red and green channels
	// angle is going through a cos and so is the length, so we see the 
	// blue channel oscillating in both dimensions the polar coordinates give us
	    // please play around with these numbers to get a better palette
    vec3 brightness = vec3(r_bri,g_bri,b_bri);
    vec3 contrast = vec3(0.2);
    vec3 osc = vec3(osc_v);
    vec3 phase = vec3(Pha, cos(u_time/23.), sin(u_time/31.));
    
    vec3 color = cosPalette(t, brightness, contrast, osc, phase);

    
    gl_FragColor = vec4(color,1.);
    
}`;


    </script>
  </body>
</html>
